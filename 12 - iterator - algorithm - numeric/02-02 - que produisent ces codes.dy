skill iterator - algorithm - numeric
exo [lwy] Que produisent ces codes

Soit la fonction `display(..)` et les tableaux d√©clar√©s.

~~~cpp
template<typename Iterator>
void display(Iterator first, Iterator last) {
   cout << "[";
   for (Iterator it = first; it != last; ++it) {
      if (it != first) cout << ", ";
      cout << *it;
   }
   cout << "]\n";
}

vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int tab[]  = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
~~~

Que produisent ces codes ? Indiquer `COMP` si erreur de compilation, `INFI` si ex√©cution infinie ou `INDE` si le r√©sultat est ind√©termin√©.

subexo [kac]
~~~cpp
// no 1
display(v.begin(), v.end());
~~~
sol [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

subexo [ahe]
~~~cpp
// no 2
display(v.end() - 1, v.end());
~~~
sol [10]

subexo [meq]
~~~cpp
// no 3
display(v.end(), v.end());
~~~
sol []

subexo [cem]
~~~cpp
// no 4
display(v.begin() + 5, v.end() - 5);
~~~
sol []

subexo [krg]
~~~cpp
// no 5
display(v.begin() + 5, v.begin() + 4);
~~~
sol INFI
exp [6, 7, 8, 9, 10, ?, ?, ?, ..., ?] ‚ö†Ô∏è les it√©rateurs sont crois√©s => boucle infinie

subexo [kof]
~~~cpp
// no 6
display(tab, tab + 3);
~~~
sol [1, 2, 3]

subexo [cgj]
~~~cpp
// no 7
display(tab, tab + 2);
~~~
sol [1, 2]

subexo [ybq]
~~~cpp
// no 8
display(tab, tab + 10);
~~~
sol [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

subexo [fuz]
~~~cpp
// no 9
display(tab, tab + 12);
~~~
sol 
- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ?, ?]
- INDE
exp ‚ö†Ô∏è en dehors du tableau => ind√©termin√©

subexo [nvv]
~~~cpp
// no 10
display(tab + 2, tab + 5);
~~~
sol [3, 4, 5]

subexo [kbt]
~~~cpp
// no 11
display(tab + 5, tab + 2);
~~~
sol INFI
exp [6, 7, 8, 9, 10, ?, ?, ?, ?, ..., ?]

‚ö†Ô∏è les it√©rateurs sont crois√©s => boucle infinie

subexo [wgv]
~~~cpp
// no 12
template <typename T>
void f(const T tab[]) {
   vector<T> v (tab.begin(), tab.end());
   display(v.begin(), v.end());
}

f(tab);
~~~
sol COMP
exp ‚ö†Ô∏è ne compile pas  
`tab` tel que re√ßu dans la fonction n'est qu'un **pointeur sur le tableau**.<br>
Il n'y a donc aucune m√©thode `tab.begin()` ou `tab.end()` √† disposition.

subexo [uqk]
~~~cpp
// no 13
template <typename T>
void f(const T tab[], size_t taille) {
   vector<T> v (tab.begin(), tab.begin() + taille);
   display(v.begin(), v.end());
}

// tab suppos√© dans le scope de d√©claration de l'appel
f(tab, sizeof(tab));
~~~
sol COMP
exp ‚ö†Ô∏è ne compile pas<br>
`tab` tel que re√ßu dans la fonction n'est qu'un **pointeur sur le tableau**.<br>
Il n'y a donc aucune m√©thode `tab.begin()` √† disposition.

**NB** cette fois la taille a √©t√© pass√©e en param√®tre et utilis√©e ici `tab.begin() + taille`

subexo [ejw]
~~~cpp
// no 14
template <typename T>
void f(const T tab[], size_t taille) {
   vector<T> v (tab, tab + taille);
   display(v.begin(), v.end());
}

// tab suppos√© dans le scope de d√©claration de l'appel
f(tab, sizeof(tab));
~~~
sol [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

exp üëç cette fois pas d'utilisation de `tab.begin()` ou `tab.end()`<br>mais de `tab` et `tab + taille` pour le constructeur de `v`.

subexo [tmx]
~~~cpp
// no 15
display(v.rbegin(), v.rend());
~~~
sol [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

subexo [vvh]
~~~cpp
// no 16
display(v.rend(), v.rbegin());
~~~
sol INDE
exp ‚ö†Ô∏è ind√©termin√©, les it√©rateurs sont crois√©s


subexo [vck]
~~~cpp
// no 17
display(v.rbegin(), v.end());
~~~
sol COMP

exp ‚ö†Ô∏è ne compile pas<br>
les it√©rateurs ne sont pas du m√™me type<br>
- `v.rbegin()` => `vector<int>::reverse_iterator`<br>
- `v.end()` => `vector<int>::iterator`<br>

subexo [ybd]
~~~cpp
// no 18
display(v.rbegin() + 1, v.rend() - 3);
~~~
sol [9, 8, 7, 6, 5, 4]
